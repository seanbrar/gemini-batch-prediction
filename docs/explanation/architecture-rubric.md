# Architecture Rubric

> How to use this rubric: Periodically score the architecture (1‚Äì5) across criteria below. Use results to prioritize refactors. See ‚ÄúArchitectural Fitness‚Äù tests in Contract-First Testing for automation ideas.

| Criterion | Excellent (5) | Good (3) | Needs Improvement (1) |
| :--- | :--- | :--- | :--- |
| **Simplicity & Elegance** üß† | The design is **profoundly simple**, almost obvious in retrospect. It uses advanced features to eliminate conceptual overhead, not add to it. Its trade-offs are explicit and don't compromise the core principle that **complexity is the enemy**. | The design is clean and avoids common complexities. It's an improvement over standard patterns but may not fully achieve that "genius" level of simplicity, perhaps retaining some familiar but non-ideal conventions. | The design feels like a complex system that has been refactored, not re-imagined. It either adds complexity to use advanced features or avoids them, resulting in boilerplate and a compromised core philosophy. |
| **Data-Centricity** üìä | State is modeled in **rich, self-validating data structures**. Behavior is composed of simple, often **pure functions** that transform this data. The flow is from one valid state to another, making complex logic unnecessary. | Data structures are well-defined but might allow for some invalid states. Behavior is mostly simple, but some functions contain moderately complex logic or side effects that aren't cleanly separated from data transformation. | The architecture relies on **simple data types** (e.g., raw `dict`s) and **complex behavior** (large functions/classes) to manage state. Logic for validation and transformation is scattered and hard to follow. |
| **Clarity & Explicitness** üîç | The architecture is **"what you see is what you get."** There is no hidden state, "magic," or action-at-a-distance. The flow of data and control is immediately obvious from reading the code. Behavior is **fully transparent**. | The design is mostly explicit but may rely on some light "magic" (e.g., clever decorators, metaprogramming) for convenience. A developer might need to "learn the tricks" of the framework to fully understand it. | The architecture relies heavily on **implicit mechanisms** that obscure what is happening. Reasoning about the system requires a debugger or deep knowledge of its internal machinery. The system is opaque. |
| **Architectural Robustness** üõ°Ô∏è | Entire categories of bugs are **structurally impossible**. Invalid data cannot be constructed. The type system and architecture guarantee correctness. The design doesn't just handle bugs; it **prevents them from existing**. | The design is robust, using strong typing and validation to prevent common bugs. However, some error states are still possible and must be handled by defensive code. It's designed *against* bugs, but they are not impossible. | Robustness relies on developer discipline, extensive runtime checks, and exception handling. The architecture **allows for fragility** and assumes the programmer will write perfect code to avoid it. |
| **DX, Testability & Maintainability** üõ†Ô∏è | The system is a **joy to work with**. Components are decoupled and can be tested in complete isolation. Reasoning about a change's impact is trivial. The API (UX) is intuitive, and the internal design (DX) is elegant. **Maintenance is easy**. | The system is testable with reasonable effort (e.g., some mocking). The API is usable and the codebase is maintainable, but a developer might hit occasional friction points. It's a **good system to work on**. | Testing is difficult, requiring complex fixtures or a live application. The system is tightly coupled, making changes risky and unpredictable. The developer experience is **frustrating**. |
| **Extensibility** üß© | The architecture has **clear and obvious extension points**. Adding planned features feels like adding a new, self-contained module. The core remains untouched, and the original principles are **reinforced**, not compromised, by new code. | The system can be extended, but it may require some minor refactoring or careful thought. Adding a feature might introduce a small amount of complexity or require touching a few different parts of the core system, but it **doesn't break the architecture**. | Adding a new feature requires significant changes to core components. The design is rigid, and each addition **progressively compromises** its simplicity and robustness. Extending the system feels like a fight. |
